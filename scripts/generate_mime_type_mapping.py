#!/usr/bin/env python3
"""Fallback generator for tdutils/generate/auto/mime_type_to_extension.cpp."""
from __future__ import annotations

import argparse
import pathlib
from typing import Iterable, List, Sequence, Tuple


def parse_gperf_entries(text: Sequence[str]) -> List[Tuple[str, str]]:
    entries: List[Tuple[str, str]] = []
    in_table = False
    for raw_line in text:
        line = raw_line.strip()
        if not in_table:
            if line == "%%":
                in_table = True
            continue
        if line == "%%":
            break
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
        if not line:
            continue
        # gperf entries are comma-separated; ignore empty trailing columns
        parts = [part.strip() for part in line.split(",") if part.strip()]
        if len(parts) < 2:
            continue
        mime_type, extension = parts[0], parts[1]
        entries.append((mime_type, extension))
    return entries


def escape_literal(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def render_cpp(entries: Iterable[Tuple[str, str]]) -> str:
    sorted_entries = sorted(entries, key=lambda item: item[0])
    lines = [
        "// This file was generated by scripts/generate_mime_type_mapping.py; DO NOT EDIT MANUALLY.\n",
        "#include \"td/utils/mime_type_to_extension.h\"\n",
        "#include \"td/utils/Slice.h\"\n",
        "#include <algorithm>\n",
        "#include <iterator>\n\n",
        "namespace td {\n",
        "namespace {\n\n",
        "struct MimeTypeExtensionEntry {\n",
        "  const char *mime_type;\n",
        "  const char *extension;\n",
        "};\n\n",
        "constexpr MimeTypeExtensionEntry MIME_TYPE_EXTENSION_MAP[] = {\n",
    ]
    for mime_type, extension in sorted_entries:
        lines.append(
            f"    {{\"{escape_literal(mime_type)}\", \"{escape_literal(extension)}\"}},\n"
        )
    lines.extend(
        [
            "};\n\n",
            "}  // namespace\n\n",
            "CSlice mime_type_to_extension(Slice mime_type) {\n",
            "  const auto begin = std::begin(MIME_TYPE_EXTENSION_MAP);\n",
            "  const auto end = std::end(MIME_TYPE_EXTENSION_MAP);\n",
            "  const auto compare_entry = [](const MimeTypeExtensionEntry &entry, Slice value) {\n",
            "    return Slice(entry.mime_type).compare(value) < 0;\n",
            "  };\n",
            "  auto it = std::lower_bound(begin, end, mime_type, compare_entry);\n",
            "  if (it != end && Slice(it->mime_type).compare(mime_type) == 0) {\n",
            "    return CSlice(it->extension);\n",
            "  }\n",
            "  return CSlice();\n",
            "}\n\n",
            "}  // namespace td\n",
        ]
    )
    return "".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("gperf_input", type=pathlib.Path)
    parser.add_argument("output", type=pathlib.Path)
    args = parser.parse_args()

    if not args.gperf_input.is_file():
        raise SystemExit(f"Unable to find gperf input file: {args.gperf_input}")

    entries = parse_gperf_entries(args.gperf_input.read_text().splitlines())
    if not entries:
        raise SystemExit(
            f"No entries found in gperf input {args.gperf_input}; cannot generate mapping"
        )

    output_text = render_cpp(entries)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(output_text)


if __name__ == "__main__":
    main()
