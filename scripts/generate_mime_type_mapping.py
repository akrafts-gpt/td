#!/usr/bin/env python3
"""Generate tdutils/generate/auto MIME type mapping sources."""
from __future__ import annotations

import argparse
import enum
import mimetypes
import pathlib
from typing import Dict, Iterable, List, Sequence, Tuple


class MappingDirection(enum.Enum):
    MIME_TO_EXTENSION = "mime-to-extension"
    EXTENSION_TO_MIME = "extension-to-mime"

    @property
    def header(self) -> str:
        if self is MappingDirection.MIME_TO_EXTENSION:
            return "td/utils/mime_type_to_extension.h"
        return "td/utils/extension_to_mime_type.h"

    @property
    def function_name(self) -> str:
        if self is MappingDirection.MIME_TO_EXTENSION:
            return "mime_type_to_extension"
        return "extension_to_mime_type"

    @property
    def key_field(self) -> str:
        if self is MappingDirection.MIME_TO_EXTENSION:
            return "mime_type"
        return "extension"

    @property
    def value_field(self) -> str:
        if self is MappingDirection.MIME_TO_EXTENSION:
            return "extension"
        return "mime_type"


def parse_gperf_entries(text: Sequence[str]) -> List[Tuple[str, str]]:
    entries: List[Tuple[str, str]] = []
    in_table = False
    for raw_line in text:
        line = raw_line.strip()
        if not in_table:
            if line == "%%":
                in_table = True
            continue
        if line == "%%":
            break
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
        if not line:
            continue
        # gperf entries are comma-separated; ignore empty trailing columns
        parts = [part.strip() for part in line.split(",") if part.strip()]
        if len(parts) < 2:
            continue
        first_value, second_value = parts[0], parts[1]
        entries.append((first_value, second_value))
    return entries


def escape_literal(value: str) -> str:
    return value.replace("\\", "\\\\").replace('"', '\\"')


def render_cpp(entries: Iterable[Tuple[str, str]], mapping: MappingDirection) -> str:
    sorted_entries = sorted(entries, key=lambda item: item[0])
    lines = [
        "// This file was generated by scripts/generate_mime_type_mapping.py; DO NOT EDIT MANUALLY.\n",
        f"#include \"{mapping.header}\"\n",
        "#include \"td/utils/Slice.h\"\n",
        "#include <algorithm>\n",
        "#include <iterator>\n\n",
        "namespace td {\n",
        "namespace {\n\n",
        "struct MimeTypeExtensionEntry {\n",
        f"  const char *{mapping.key_field};\n",
        f"  const char *{mapping.value_field};\n",
        "};\n\n",
        "constexpr MimeTypeExtensionEntry MIME_TYPE_EXTENSION_MAP[] = {\n",
    ]
    for key, value in sorted_entries:
        lines.append(
            f"    {{\"{escape_literal(key)}\", \"{escape_literal(value)}\"}},\n"
        )
    lines.extend(
        [
            "};\n\n",
            "}  // namespace\n\n",
            f"CSlice {mapping.function_name}(Slice {mapping.key_field}) {{\n",
            "  const auto begin = std::begin(MIME_TYPE_EXTENSION_MAP);\n",
            "  const auto end = std::end(MIME_TYPE_EXTENSION_MAP);\n",
            "  const auto compare_entry = [](const MimeTypeExtensionEntry &entry, Slice value) {\n",
            f"    return Slice(entry.{mapping.key_field}).compare(value) < 0;\n",
            "  };\n",
            f"  auto it = std::lower_bound(begin, end, {mapping.key_field}, compare_entry);\n",
            f"  if (it != end && Slice(it->{mapping.key_field}).compare({mapping.key_field}) == 0) {{\n",
            f"    return CSlice(it->{mapping.value_field});\n",
            "  }\n",
            "  return CSlice();\n",
            "}\n\n",
            "}  // namespace td\n",
        ]
    )
    return "".join(lines)


def entries_from_stdlib_mimetypes(mapping: MappingDirection) -> List[Tuple[str, str]]:
    mimetypes.init()
    preferred_mapping: Dict[str, str] = {}

    def add_entries(source: Dict[str, str]) -> None:
        for ext, mime in source.items():
            normalized_ext = ext.lstrip(".").strip().lower()
            normalized_mime = mime.strip().lower()
            if not normalized_ext or "/" not in normalized_mime:
                continue
            if mapping is MappingDirection.MIME_TO_EXTENSION:
                current = preferred_mapping.get(normalized_mime)
                if current is None or len(normalized_ext) < len(current):
                    preferred_mapping[normalized_mime] = normalized_ext
            else:
                preferred_mapping.setdefault(normalized_ext, normalized_mime)

    add_entries(mimetypes.types_map)
    add_entries(mimetypes.common_types)

    return sorted(preferred_mapping.items(), key=lambda item: item[0])


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--gperf-input", type=pathlib.Path)
    parser.add_argument(
        "--mapping",
        choices=[item.value for item in MappingDirection],
        default=MappingDirection.MIME_TO_EXTENSION.value,
        help="Select which mapping to generate.",
    )
    parser.add_argument(
        "--use-stdlib",
        action="store_true",
        help="Use Python's mimetypes module instead of a gperf input file.",
    )
    parser.add_argument("--output", required=True, type=pathlib.Path)
    args = parser.parse_args()

    entries: List[Tuple[str, str]]
    mapping = MappingDirection(args.mapping)

    if args.gperf_input:
        if not args.gperf_input.is_file():
            raise SystemExit(f"Unable to find gperf input file: {args.gperf_input}")
        entries = parse_gperf_entries(args.gperf_input.read_text().splitlines())
        if not entries:
            raise SystemExit(
                f"No entries found in gperf input {args.gperf_input}; cannot generate mapping"
            )
    elif args.use_stdlib:
        entries = entries_from_stdlib_mimetypes(mapping)
        if not entries:
            raise SystemExit("Unable to derive MIME type mapping from Python stdlib")
    else:
        raise SystemExit("Either --gperf-input or --use-stdlib must be provided")

    output_text = render_cpp(entries, mapping)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(output_text)


if __name__ == "__main__":
    main()
